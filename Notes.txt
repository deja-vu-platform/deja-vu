11/20/2016 test notes

things that I'd really like:
	a box (empty box component) so that I can set add sorts of background colors
	grouping and moving together
	changing text size significantly
	feedback on image loading or is name is not acceptable

things I did not like:
	working while zoomed then coming back results in incorrect placement of components
	grids seems to not be functioning correctly, adding components may not correctly update the grid
	menu and dragging handle may get hidden under other components

11/30/2016 issues
x color change does not penetrate the recursive components
link between components not remembered
	this is working but implem is skecthy and needs work
	only remembered to one level: needs to be fully recursive
	needs to be refreshed for changes to show
x background color is not remembered
x zoom does not work very well (ratios not zoomed)
x list component disappears
x need to consolidate the code into smaller chunks
x need to update view to work with components (maybe view should be moved into component containers?)
x resizing upwards does not change the top, left position, just the size!!
x at a lot of places, using selected user component as opposed to a given component might cause problems
x need ui components for moving up and down the stack order.
how to allow copies of the same component in multiple places (same id)?
	this is currently working, but implem is sketchy and needs work

/** IGNORE THIS!	
**1/10/2017 issues
**x made "main" a property for the template object that the user can make instances of, but the implementation
**is a bit sketchy because they are both "UserComponent"s. Might be actually better to seperate them into 
**UserComponentTemplate and UserComponentInstance or something...
**Here's the idea:
**	Have two classes Template and Instance (or some other names)
**	Instance has parentId and custom changes including styles and resize (maybe)
**	Then in DISPLAY (which is already recursive), if it is of type instance, we read from the project
**		(side note, if the user is deleting some UserComponentTemplate, we warn them that all uses of it will be deleted,
**		and delete them as we find them (ie, can't find it in the Project))
**	
**	So, the allowed structure is
**	
**	BaseComponent (is like a base case)
**	UserComponentTemplate: 
**		BaseComponent + UserComponentInstance (ie, just a reference)
**	UserComponentInstance: ref back to UserComponentTemplate + Custom changes
**	
**	1/16/2017 question: how to save custom changes in instance of a base component, eg a link or a label to particular values?
**		So what are things that can change? 
**			For UserWidgetTemplate:
**				(saved in main?)
**				font size, text color, background color
**				values for base widgets
**			For UserWidgetInstance:
**				(saved in custom?)
**				font size, text color, background color
**				values for base widgets
**				
**				
**		customChanges = {
**			parentId (UserWidget that is the immediate parent of the component):{
**				baseWidgetType/Id:{
**					changes/values
**				}
**				UserWidgetChanges?
**			} 
**		}
**		
**		So in display we will do:
**			Look up parent Id (the UserWidgetTemplate) and get the info from main, and display those
**			then look up the info from custom and display those and override
**			
**		BUT! For base widgets, their particular values are stored in the objects themselves, should we move them to their containing
**		widget? Or do we just keep it as is? Probably keep it as is, so we can just reuse the method for displaying that we have currently.
**		
**/		
		
		
ALSO, change userCOMPONENT to userWidget
	underway
	mostly done, still have the css class names left

AND change WIDGET to DRAG-HANDLE
	done

1/16/2017 notes
	to allow changes in userInstance widgets such as a inner link or an inner label? Probably. In that case,
	the relevant function, registerTooltipBtnHandlers, needs to be updated.

	Restructuring notes:
		Details in OneNote
		
		Main Ideas: 
			*Layers* of trees (*levels*) of changes
			Templates and Instances will have the same structure, only difference is a template is a child of the project and 
			a Instance is a child of a UserWidget
			Now, the tree is structured like this
				
				Template Widget
					id (which is to be used as the parentId)
					immidiate children ids (TemplateWidget)
					TREE of changes
				

				Instance Widget
					id
					parentId (Template Widget)
					TREE of changes
					
				
				TREE of changes 
					if any descendant is changed at this level, save
					path to child, and then the change
					widgetInstanceId:{ (= top level Id of the current widget)
						changes : changes, 
						widgetInstanceId:{
							changes : changes,
							widgetInstanceId:{
								...
							}
						},
						widgetInstanceId:{
							changes : changes,
							widgetInstanceId:{
								...
							}
						},
						...
					}

// Tree of Changes
// widgetInstanceId:{ (= top level Id of the current widget)
//     properties : {
//        layout : {
//              stackOrder: []
//        },
//        styles : {
//              custom: {}, bsClasses: {}
//        }
//     },
//     children:{
//          widgetInstanceId:{
//                properties : changes,
//                  children: {
//                    widgetInstanceId:{
//                      ...
//                    },
//                     widgetInstanceId:{
//                       ...
//                     }
//              }
//      }
//
// },
// 

				
				// we use InstanceIds because at the point this is used, we don't care about the template,
				// but we DO care about the unique path to this widget!				

				the changes at any *level* is the default and overrides any unspecified values at *levels* below it
				but any changes at the same *level* at a higher *layer* can override this change.
				
				higher level overrides unspecifieds at lower level
				higher layer but same level overrides specified (and unspecified) changes at that level, and unspecified changes
					below that level (will behave like a new default at that level)
				
				
				